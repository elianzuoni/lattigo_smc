//Encryption-to-shares protocol: the parties switch from an encrypted to a additive-secret-shared plaintext.
//The root is special (it is the "master" defined in dbfv): it aggregates re-encryption shares by the other nodes
//to produce its own additive share, it does not generate any re-encryption share.
//The steps are:
//
// Method Init:
// 0) Every node initialises the protocol variables.
// Method Start:
// 1) The root sends the wake-up message to itself.
// Method Dispatch
// 2) Every node waits to receive the wake-up message, then re-sends it to children.
// 		3a) If node is a leaf, it computes its re-encryption share, and sends it to its parent.
//		3b) Else, if not root, it computes its own re-encryption share, waits to receive it from every child,
//		    aggregates them, and sends to parent.
//		3c) If root, only the additive share is generated by the combined re-encryption share
// 4) In any case, the additive share is returned by putting it into its dedicated channel.

package protocols

import (
	"errors"
	"github.com/ldsec/lattigo/bfv"
	"github.com/ldsec/lattigo/dbfv"
	"go.dedis.ch/onet/v3"
	"go.dedis.ch/onet/v3/log"
)

//CollectiveKeyGenerationProtocolName name of protocol for onet
const EncryptionToSharesProtocolName = "EncryptionToShares"

func init() {

	if _, err := onet.GlobalProtocolRegister(EncryptionToSharesProtocolName, NewEncryptionToSharesProtocol); err != nil {
		log.ErrFatal(err, "Could not register EncryptionToShares protocol : ")
	}

}

// NewEncryptionToSharesProtocol is called when a new protocol is started.
// It deals with the onet-related variables: the channels and the TreeNodeInstance.
func NewEncryptionToSharesProtocol(n *onet.TreeNodeInstance) (onet.ProtocolInstance, error) {
	log.Lvl1("NewEncryptionToSharesProtocol called")

	p := &EncryptionToSharesProtocol{
		TreeNodeInstance: n,
	}

	//No need to initialise the channels: onet.RegisterChannels will do it for us.
	if e := p.RegisterChannels(&p.channelStart, &p.channelDecShares); e != nil {
		return nil, errors.New("Could not register channel: " + e.Error())
	}

	return p, nil
}

// Init initialises every variable needed at some phase of the protocol.
// It is not done in the constructor, but it should be done before starting.
func (p *EncryptionToSharesProtocol) Init(params *bfv.Parameters, sigmaSmudging float64,
	sk *bfv.SecretKey, ct *bfv.Ciphertext) error {
	p.E2SProtocol = dbfv.NewE2SProtocol(params, sigmaSmudging)

	p.sk = *sk
	p.ct = ct

	p.ChannelAddShare = make(chan dbfv.AdditiveShare)

	return nil
}

/****************ONET HANDLERS ******************/

//Start starts the protocol (only called at root).
func (p *EncryptionToSharesProtocol) Start() error {
	log.Lvl2(p.ServerIdentity(), "Started Encryption-to-Shares protocol")
	//Step 1: send wake-up message to self
	return p.SendTo(p.TreeNode(), &Start{})
}

// Dispatch is called at each node to run the protocol.
// It implements the main protocol logic.
func (p *EncryptionToSharesProtocol) Dispatch() error {
	var decShare dbfv.E2SDecryptionShare          // Will be sent to parent
	var childDecShares []StructE2SDecryptionShare //Will contain children's decryption shares
	var addShare dbfv.AdditiveShare               //Will be returned to caller via ChannelAddShare

	decShare, addShare = p.AllocateShares()

	log.Lvl3(p.ServerIdentity(), " Dispatching ; is root = ", p.IsRoot())

	// Step 2: wait for wake-up, then send it to children
	log.Lvl3("Waiting for wake-up message")
	wakeup := <-p.channelStart
	//Send wake-up message to all children
	log.Lvl3("Sending wake-up message")
	err := p.SendToChildren(&wakeup)
	if err != nil {
		log.ErrFatal(err, "Could not send wake up message ")
		return err
	}

	// Step 3: case leaf / intermediate / root.
	if p.IsLeaf() {
		// Step 3a: generate decryption share, then send it to parent.
		p.GenSharesSlave(p.sk, p.ct, decShare, addShare)
		if err = p.SendToParent(&decShare); err != nil {
			log.ErrFatal(err, "Could not send decryption share to parent ")
			return err
		}
	} else if !p.IsRoot() {
		// Step 3b: generate decryption share, then wait for children's share,
		// then aggregate, then send to parent.
		p.GenSharesSlave(p.sk, p.ct, decShare, addShare)
		childDecShares = <-p.channelDecShares // Blocking wait.

		for _, share := range childDecShares {
			p.AggregateDecryptionShares(decShare, share.E2SDecryptionShare, decShare)
		}

		if err = p.SendToParent(&decShare); err != nil {
			log.ErrFatal(err, "Could not send decryption share to parent ")
			return err
		}
	} else {
		// Step 3c: wait for children's share, then aggregate, then generate additive share
		childDecShares = <-p.channelDecShares // Blocking wait.

		for _, share := range childDecShares {
			p.AggregateDecryptionShares(decShare, share.E2SDecryptionShare, decShare)
		}

		p.GenShareMaster(p.sk, p.ct, decShare, addShare)
	}

	// Step 4: return the generated additive share to caller via the channel
	p.ChannelAddShare <- addShare

	p.Done() //Onet requirement to finalise the protocol

	return nil
}
